<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>NEXT PERMUTATION(全排列生成算法)</title>
      <link href="/posts/bd3fa96e/"/>
      <url>/posts/bd3fa96e/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>** NEXT PERMUTATION(全排列生成算法)：** &lt;Excerpt in index | 首页摘要&gt;</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><p>Next Permutation<br>Time Limit: 1000 MS    Memory Limit: 65536 K<br>Total Submit: 96(47 users)    Total Accepted: 58(44 users)    Rating:     Special Judge: No<br>Description<br>A permutation is each one of the (n!) possible arrangements the elements in a set can take (where n is the number of elements in the set). Different permutations can be ordered according on how they compare lexicographically to each other; the first such-sorted possible permutation (the one that would compare lexicographically smaller to all other permutations) is the one which has all its elements sorted in ascending order, and the largest has all its elements sorted in descending order.   </p><p>You need to determine the next k-th higher permutation of a given permutation of the set {1, 2, 3 … n}.   </p><p>Input<br>There are multiple test cases. The first line of input is an integer T indicating the number of test cases. Then T test cases follow.   </p><p>For each test case:   </p><p>Line 1. This line contains two space-separated integers n and k (1 ≤ n, k ≤ 1000)   </p><p>Line 2. This line contains n space-separated integers indicating a permutation of {1, 2, 3 … n}   </p><p>Output<br>For each test case:   </p><p>Line 1. Output the next k-th higher permutation of the set {1, 2, 3 … n}.Separate the numbers by a single space.</p><p>Sample Input<br>3   </p><p>3 1   </p><p>2 3 1   </p><p>3 1   </p><p>3 2 1   </p><p>10 2   </p><p>1 2 3 4 5 6 7 8 9 10   </p><p>Sample Output<br>3 1 2   </p><p>1 2 3   </p><p>1 2 3 4 5 6 7 9 8 10   </p><p>Hint<br>In the first sample, all the permutations of {1, 2, 3} in lexicographical order are as below:   </p><p>{1, 2, 3}   </p><p>{1, 3, 2}   </p><p>{2, 1, 3}   </p><p>{2, 3, 1}   </p><p>{3, 1, 2}   </p><p>{3, 2, 1}   </p><p>So the next first permutation of {2, 3, 1} is {3, 1, 2}.   </p><p>Source<br>哈理工2012春季校赛 - 网络预选赛<br>Author<br>齐达拉图@HRBUST   </p><p>这是一个求一个排序的下一个排列的函数，可以遍历全排列,要包含头文件<algorithm><br>下面是代码，与之完全相反的函数还有prev_permutation   </algorithm></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[1001];</span><br><span class="line">    int T;</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;T))</span><br><span class="line">    &#123;</span><br><span class="line">        while(T--)</span><br><span class="line">        &#123;</span><br><span class="line">            int n,k;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;n,&amp;k);</span><br><span class="line">            int i;</span><br><span class="line">            for(i&#x3D;0;i&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                scanf(&quot;%d&quot;,&amp;a[i]);    </span><br><span class="line">            &#125;</span><br><span class="line">            while(k--)</span><br><span class="line">            &#123;</span><br><span class="line">                next_permutation(a,a+n);</span><br><span class="line">            &#125;</span><br><span class="line">            for(i&#x3D;0;i&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;%d%c&quot;,a[i],i&#x3D;&#x3D;n-1? &#39;\n&#39;:&#39; &#39;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>一下转自：作者：王雨濛；新浪微博：@吉祥村码农；来源：《程序控》博客 – <a href="http://www.cnblogs.com/devymex/" target="_blank" rel="external nofollow noreferrer noopener">http://www.cnblogs.com/devymex/</a>  </p><p>概念<br>全排列的生成算法有很多种，有递归遍例，也有循环移位法等等。C++/STL中定义的next_permutation和prev_permutation函数则是非常灵活且高效的一种方法，它被广泛的应用于为指定序列生成不同的排列。本文将详细的介绍prev_permutation函数的内部算法。   </p><p>按照STL文档的描述，next_permutation函数将按字母表顺序生成给定序列的下一个较大的序列，直到整个序列为减序为止。prev_permutation函数与之相反，是生成给定序列的上一个较小的序列。二者原理相同，仅遍例顺序相反，这里仅以next_permutation为例介绍算法。   </p><p>下文内容都基于一个假设，即序列中不存在相同元素。对序列大小的比较做出定义：两个长度相同的序列，从两者的第一个元素开始向后比较，直到出现一个不同元素（也可能就是第它们的第一个元素），该元素较大的序列为大，反之序列为小；若一直到最后一个元素都相同，那么两个序列相等。</p><p>设当前序列为pn，下一个较大的序列为pn+1，那么不存在pm，使得pn &lt; pm &lt; pn+1。   </p><p>问题<br>给定任意非空序列，生成下一个较大或较小的序列。    </p><p>复杂度<br>最好的情况为pn的最右边的2个元素构成一个最小的增序子集，交换次数为1，复杂度为O(1)，最差的情况为1个元素最小，而右面的所有元素构成减序子集，这样需要先将第1个元素换到最右，然后反转右面的所有元素。交换次数为1+(n-1)/2，复杂度为O(n)。因为各种排列等可能出现，所以平均复杂度即为O(n)。   </p><p>扩展   </p><ol><li>能否直接算出集合{1, 2, …, m}的第n个排列？   </li></ol><p>设某个集合{a1, a2, …, am}（a1&lt;a2&lt;…&lt;am）构成的某种序列pn，基于以上分析易证得：若as&lt;at，那么将as作为第1个元素的所有序列一定都小于at作为第1个元素的任意序列。同理可证得：第1个元素确定后，剩下的元素中若as’&lt;at’，那么将as’作为第2个元素的所有序列一定都小于作为第2个元素的任意序列。例如4个数的集合{2, 3, 4, 6}构成的序列中，以3作为第1个元素的序列一定小于以4或6作为第1个元素的序列；3作为第1个元素的前题下，2作为第2个元素的序列一定小于以4或6作为第2个元素的序列。   </p><p>推广可知，在确定前i（i&lt;n）个元素后，在剩下的m-i=s个元素的集合{aq1, aq2, …, aq3}（aq1&lt;aq2&lt;…&lt;aqm）中，以aqj作为第i+1个元素的序列一定小于以aqj+1作为第i+1个元素的序列。由此可知：在确定前i个元素后，一共可生成s!种连续大小的序列。   </p><p>根据以上分析，对于给定的n（必有n&lt;=m!）可以从第1位开始向右逐位地确定每一位元素。在第1位不变的前题下，后面m-1位一共可以生成(m-1)!中连续大小的序列。若n&gt;(m-1)!，则第1位不会是a1，n中可以容纳x个(m-1)!即代表第1位是ax。在确定第1位后，将第1位从原集合中删除，得到新的集合{aq1, aq2, …, aq3}（aq1&lt;aq2&lt;…&lt;aqm），然后令n1=n-x(m-1)!，求这m-1个数中生成的第n1个序列的第1位。   </p><p>举例说明：如7个数的集合为{1, 2, 3, 4, 5, 6, 7}，要求出第n=1654个排列。   </p><p>(1654 / 6!)取整得2，确定第1位为3，剩下的6个数{1, 2, 4, 5, 6, 7}，求第1654 % 6!=214个序列；   </p><p>(214 / 5!)取整得1，确定第2位为2，剩下5个数{1, 4, 5, 6, 7}，求第214 % 5!=94个序列；   </p><p>(94 / 4!)取整得3，确定第3位为6，剩下4个数{1, 4, 5, 7}，求第94 % 4!=22个序列；   </p><p>(22 / 3!)取整得3，确定第4位为7，剩下3个数{1, 4, 5}，求第22 % 3!=4个序列；   </p><p>(4 / 2!)得2，确定第5为5，剩下2个数{1, 4}；由于4 % 2!=0，故第6位和第7位为增序&lt;1 4&gt;；    </p><p>因此所有排列为：3267514。   </p><ol start="2"><li>给定一种排列，如何算出这是第几个排列呢？   </li></ol><p>和前一个问题的推导过程相反。例如3267514：   </p><p>后6位的全排列为6!，3为{1, 2, 3 ,4 , 5, 6, 7}中第2个元素（从0开始计数），故2*720=1440；   </p><p>后5位的全排列为5!，2为{1, 2, 4, 5, 6, 7}中第1个元素，故1*5!=120；   </p><p>后4位的全排列为4!，6为{1, 4, 5, 6, 7}中第3个元素，故3*4!=72；   </p><p>后3位的全排列为3!，7为{1, 4, 5, 7}中第3个元素，故3*3!=18；   </p><p>后2位的全排列为2!，5为{1, 4, 5}中第2个元素，故2*2!=4；   </p><p>最后2位为增序，因此计数0，求和得：1440+120+72+18+4=1654   </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">&#x2F;&#x2F;主函数，算法详见相关说明</span><br><span class="line">int main(void) &#123;</span><br><span class="line">    &#x2F;&#x2F;循环处理输入的每一个字符串</span><br><span class="line">    for (string str; cin &gt;&gt; str;) &#123;</span><br><span class="line">        if (str.empty()) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果字符串只有1个字符，则直接输出结束</span><br><span class="line">        if (str.length() &lt;&#x3D; 1) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;No more Permutation&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;iPivot为右边最大减序子集左边相邻的一个元素</span><br><span class="line">        string::iterator iPivot &#x3D; str.end(), iNewHead;</span><br><span class="line">        &#x2F;&#x2F;查找右边最大的减序子集</span><br><span class="line">        for (--iPivot; iPivot !&#x3D; str.begin(); --iPivot) &#123;</span><br><span class="line">            if (*(iPivot - 1) &lt;&#x3D; *iPivot ) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果整个序列都为减序，则重排结束。</span><br><span class="line">        if (iPivot &#x3D;&#x3D; str.begin()) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;No more Permutation&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;iPivot指向子集左边相邻的一个元素</span><br><span class="line">        iPivot--;</span><br><span class="line">        &#x2F;&#x2F;iNewHead为仅比iPivot大的元素，在右侧减序子集中寻找</span><br><span class="line">        for (iNewHead &#x3D; iPivot + 1; iNewHead !&#x3D; str.end(); ++iNewHead) &#123;</span><br><span class="line">            if (*iNewHead &lt; *iPivot) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;交换iPivot和iNewHead的值，但不改变它们的指向</span><br><span class="line">        iter_swap(iPivot, --iNewHead);</span><br><span class="line">        &#x2F;&#x2F;反转右侧减序子集，使之成为最小的增序子集</span><br><span class="line">        reverse(iPivot + 1, str.end());</span><br><span class="line">        &#x2F;&#x2F;本轮重排完成，输出结果</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
